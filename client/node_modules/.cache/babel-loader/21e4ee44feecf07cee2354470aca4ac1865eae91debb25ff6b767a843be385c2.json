{"ast":null,"code":"import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-38f9a32a.mjs';\nimport '@trpc/server/shared';\n\n/* istanbul ignore next -- @preserve */\nconst retryDelay = attemptIndex => attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\nfunction createWSClient(opts) {\n  const {\n    url,\n    WebSocket: WebSocketImpl = WebSocket,\n    retryDelayMs: retryDelayFn = retryDelay,\n    onOpen,\n    onClose\n  } = opts;\n  /* istanbul ignore next -- @preserve */\n  if (!WebSocketImpl) {\n    throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n  }\n  /**\n  * outgoing messages buffer whilst not open\n  */\n  let outgoing = [];\n  const pendingRequests = Object.create(null);\n  let connectAttempt = 0;\n  let dispatchTimer = null;\n  let connectTimer = null;\n  let activeConnection = createWS();\n  let state = 'connecting';\n  /**\n  * tries to send the list of messages\n  */\n  function dispatch() {\n    if (state !== 'open' || dispatchTimer) {\n      return;\n    }\n    dispatchTimer = setTimeout(() => {\n      dispatchTimer = null;\n      if (outgoing.length === 1) {\n        // single send\n        activeConnection.send(JSON.stringify(outgoing.pop()));\n      } else {\n        // batch send\n        activeConnection.send(JSON.stringify(outgoing));\n      }\n      // clear\n      outgoing = [];\n    });\n  }\n  function tryReconnect() {\n    if (connectTimer !== null || state === 'closed') {\n      return;\n    }\n    const timeout = retryDelayFn(connectAttempt++);\n    reconnectInMs(timeout);\n  }\n  function reconnect() {\n    state = 'connecting';\n    const oldConnection = activeConnection;\n    activeConnection = createWS();\n    closeIfNoPending(oldConnection);\n  }\n  function reconnectInMs(ms) {\n    if (connectTimer) {\n      return;\n    }\n    state = 'connecting';\n    connectTimer = setTimeout(reconnect, ms);\n  }\n  function closeIfNoPending(conn) {\n    // disconnect as soon as there are are no pending result\n    const hasPendingRequests = Object.values(pendingRequests).some(p => p.ws === conn);\n    if (!hasPendingRequests) {\n      conn.close();\n    }\n  }\n  function closeActiveSubscriptions() {\n    Object.values(pendingRequests).forEach(req => {\n      if (req.type === 'subscription') {\n        req.callbacks.complete();\n      }\n    });\n  }\n  function resumeSubscriptionOnReconnect(req) {\n    if (outgoing.some(r => r.id === req.op.id)) {\n      return;\n    }\n    request(req.op, req.callbacks);\n  }\n  function createWS() {\n    const urlString = typeof url === 'function' ? url() : url;\n    const conn = new WebSocketImpl(urlString);\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    conn.addEventListener('open', () => {\n      /* istanbul ignore next -- @preserve */if (conn !== activeConnection) {\n        return;\n      }\n      connectAttempt = 0;\n      state = 'open';\n      onOpen?.();\n      dispatch();\n    });\n    conn.addEventListener('error', () => {\n      if (conn === activeConnection) {\n        tryReconnect();\n      }\n    });\n    const handleIncomingRequest = req => {\n      if (req.method === 'reconnect' && conn === activeConnection) {\n        if (state === 'open') {\n          onClose?.();\n        }\n        reconnect();\n        // notify subscribers\n        for (const pendingReq of Object.values(pendingRequests)) {\n          if (pendingReq.type === 'subscription') {\n            resumeSubscriptionOnReconnect(pendingReq);\n          }\n        }\n      }\n    };\n    const handleIncomingResponse = data => {\n      const req = data.id !== null && pendingRequests[data.id];\n      if (!req) {\n        // do something?\n        return;\n      }\n      req.callbacks.next?.(data);\n      if (req.ws !== activeConnection && conn === activeConnection) {\n        const oldWs = req.ws;\n        // gracefully replace old connection with this\n        req.ws = activeConnection;\n        closeIfNoPending(oldWs);\n      }\n      if ('result' in data && data.result.type === 'stopped' && conn === activeConnection) {\n        req.callbacks.complete();\n      }\n    };\n    conn.addEventListener('message', ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      if ('method' in msg) {\n        handleIncomingRequest(msg);\n      } else {\n        handleIncomingResponse(msg);\n      }\n      if (conn !== activeConnection || state === 'closed') {\n        // when receiving a message, we close old connection that has no pending requests\n        closeIfNoPending(conn);\n      }\n    });\n    conn.addEventListener('close', ({\n      code\n    }) => {\n      if (state === 'open') {\n        onClose?.({\n          code\n        });\n      }\n      if (activeConnection === conn) {\n        // connection might have been replaced already\n        tryReconnect();\n      }\n      for (const [key, req] of Object.entries(pendingRequests)) {\n        if (req.ws !== conn) {\n          continue;\n        }\n        if (state === 'closed') {\n          // If the connection was closed, we just call `complete()` on the request\n          delete pendingRequests[key];\n          req.callbacks.complete?.();\n          continue;\n        }\n        // The connection was closed either unexpectedly or because of a reconnect\n        if (req.type === 'subscription') {\n          // Subscriptions will resume after we've reconnected\n          resumeSubscriptionOnReconnect(req);\n        } else {\n          // Queries and mutations will error if interrupted\n          delete pendingRequests[key];\n          req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError('WebSocket closed prematurely')));\n        }\n      }\n    });\n    return conn;\n  }\n  function request(op, callbacks) {\n    const {\n      type,\n      input,\n      path,\n      id\n    } = op;\n    const envelope = {\n      id,\n      method: type,\n      params: {\n        input,\n        path\n      }\n    };\n    pendingRequests[id] = {\n      ws: activeConnection,\n      type,\n      callbacks,\n      op\n    };\n    // enqueue message\n    outgoing.push(envelope);\n    dispatch();\n    return () => {\n      const callbacks = pendingRequests[id]?.callbacks;\n      delete pendingRequests[id];\n      outgoing = outgoing.filter(msg => msg.id !== id);\n      callbacks?.complete?.();\n      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === 'subscription') {\n        outgoing.push({\n          id,\n          method: 'subscription.stop'\n        });\n        dispatch();\n      }\n    };\n  }\n  return {\n    close: () => {\n      state = 'closed';\n      onClose?.();\n      closeActiveSubscriptions();\n      closeIfNoPending(activeConnection);\n      clearTimeout(connectTimer);\n      connectTimer = null;\n    },\n    request,\n    getConnection() {\n      return activeConnection;\n    }\n  };\n}\nclass TRPCWebSocketClosedError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'TRPCWebSocketClosedError';\n    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n  }\n}\n/**\n * @see https://trpc.io/docs/client/links/wsLink\n */\nfunction wsLink(opts) {\n  return runtime => {\n    const {\n      client\n    } = opts;\n    return ({\n      op\n    }) => {\n      return observable(observer => {\n        const {\n          type,\n          path,\n          id,\n          context\n        } = op;\n        const input = runtime.transformer.serialize(op.input);\n        const unsub = client.request({\n          type,\n          path,\n          input,\n          id,\n          context\n        }, {\n          error(err) {\n            observer.error(err);\n            unsub();\n          },\n          complete() {\n            observer.complete();\n          },\n          next(message) {\n            const transformed = transformResult(message, runtime);\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error));\n              return;\n            }\n            observer.next({\n              result: transformed.result\n            });\n            if (op.type !== 'subscription') {\n              // if it isn't a subscription we don't care about next response\n              unsub();\n              observer.complete();\n            }\n          }\n        });\n        return () => {\n          unsub();\n        };\n      });\n    };\n  };\n}\nexport { createWSClient, wsLink };","map":{"version":3,"names":["observable","t","transformResult","T","TRPCClientError","retryDelay","attemptIndex","Math","min","createWSClient","opts","url","WebSocket","WebSocketImpl","retryDelayMs","retryDelayFn","onOpen","onClose","Error","outgoing","pendingRequests","Object","create","connectAttempt","dispatchTimer","connectTimer","activeConnection","createWS","state","dispatch","setTimeout","length","send","JSON","stringify","pop","tryReconnect","timeout","reconnectInMs","reconnect","oldConnection","closeIfNoPending","ms","conn","hasPendingRequests","values","some","p","ws","close","closeActiveSubscriptions","forEach","req","type","callbacks","complete","resumeSubscriptionOnReconnect","r","id","op","request","urlString","clearTimeout","addEventListener","handleIncomingRequest","method","pendingReq","handleIncomingResponse","data","next","oldWs","result","msg","parse","code","key","entries","error","from","TRPCWebSocketClosedError","input","path","envelope","params","push","filter","readyState","OPEN","getConnection","constructor","message","name","setPrototypeOf","prototype","wsLink","runtime","client","observer","context","transformer","serialize","unsub","err","transformed","ok"],"sources":["/Users/danilakiva/jspool/s21_arcade_games/client/node_modules/@trpc/client/dist/links/wsLink.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-38f9a32a.mjs';\nimport '@trpc/server/shared';\n\n/* istanbul ignore next -- @preserve */ const retryDelay = (attemptIndex)=>attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n\nfunction createWSClient(opts) {\n    const { url , WebSocket: WebSocketImpl = WebSocket , retryDelayMs: retryDelayFn = retryDelay , onOpen , onClose ,  } = opts;\n    /* istanbul ignore next -- @preserve */ if (!WebSocketImpl) {\n        throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n    }\n    /**\n   * outgoing messages buffer whilst not open\n   */ let outgoing = [];\n    const pendingRequests = Object.create(null);\n    let connectAttempt = 0;\n    let dispatchTimer = null;\n    let connectTimer = null;\n    let activeConnection = createWS();\n    let state = 'connecting';\n    /**\n   * tries to send the list of messages\n   */ function dispatch() {\n        if (state !== 'open' || dispatchTimer) {\n            return;\n        }\n        dispatchTimer = setTimeout(()=>{\n            dispatchTimer = null;\n            if (outgoing.length === 1) {\n                // single send\n                activeConnection.send(JSON.stringify(outgoing.pop()));\n            } else {\n                // batch send\n                activeConnection.send(JSON.stringify(outgoing));\n            }\n            // clear\n            outgoing = [];\n        });\n    }\n    function tryReconnect() {\n        if (connectTimer !== null || state === 'closed') {\n            return;\n        }\n        const timeout = retryDelayFn(connectAttempt++);\n        reconnectInMs(timeout);\n    }\n    function reconnect() {\n        state = 'connecting';\n        const oldConnection = activeConnection;\n        activeConnection = createWS();\n        closeIfNoPending(oldConnection);\n    }\n    function reconnectInMs(ms) {\n        if (connectTimer) {\n            return;\n        }\n        state = 'connecting';\n        connectTimer = setTimeout(reconnect, ms);\n    }\n    function closeIfNoPending(conn) {\n        // disconnect as soon as there are are no pending result\n        const hasPendingRequests = Object.values(pendingRequests).some((p)=>p.ws === conn);\n        if (!hasPendingRequests) {\n            conn.close();\n        }\n    }\n    function closeActiveSubscriptions() {\n        Object.values(pendingRequests).forEach((req)=>{\n            if (req.type === 'subscription') {\n                req.callbacks.complete();\n            }\n        });\n    }\n    function resumeSubscriptionOnReconnect(req) {\n        if (outgoing.some((r)=>r.id === req.op.id)) {\n            return;\n        }\n        request(req.op, req.callbacks);\n    }\n    function createWS() {\n        const urlString = typeof url === 'function' ? url() : url;\n        const conn = new WebSocketImpl(urlString);\n        clearTimeout(connectTimer);\n        connectTimer = null;\n        conn.addEventListener('open', ()=>{\n            /* istanbul ignore next -- @preserve */ if (conn !== activeConnection) {\n                return;\n            }\n            connectAttempt = 0;\n            state = 'open';\n            onOpen?.();\n            dispatch();\n        });\n        conn.addEventListener('error', ()=>{\n            if (conn === activeConnection) {\n                tryReconnect();\n            }\n        });\n        const handleIncomingRequest = (req)=>{\n            if (req.method === 'reconnect' && conn === activeConnection) {\n                if (state === 'open') {\n                    onClose?.();\n                }\n                reconnect();\n                // notify subscribers\n                for (const pendingReq of Object.values(pendingRequests)){\n                    if (pendingReq.type === 'subscription') {\n                        resumeSubscriptionOnReconnect(pendingReq);\n                    }\n                }\n            }\n        };\n        const handleIncomingResponse = (data)=>{\n            const req = data.id !== null && pendingRequests[data.id];\n            if (!req) {\n                // do something?\n                return;\n            }\n            req.callbacks.next?.(data);\n            if (req.ws !== activeConnection && conn === activeConnection) {\n                const oldWs = req.ws;\n                // gracefully replace old connection with this\n                req.ws = activeConnection;\n                closeIfNoPending(oldWs);\n            }\n            if ('result' in data && data.result.type === 'stopped' && conn === activeConnection) {\n                req.callbacks.complete();\n            }\n        };\n        conn.addEventListener('message', ({ data  })=>{\n            const msg = JSON.parse(data);\n            if ('method' in msg) {\n                handleIncomingRequest(msg);\n            } else {\n                handleIncomingResponse(msg);\n            }\n            if (conn !== activeConnection || state === 'closed') {\n                // when receiving a message, we close old connection that has no pending requests\n                closeIfNoPending(conn);\n            }\n        });\n        conn.addEventListener('close', ({ code  })=>{\n            if (state === 'open') {\n                onClose?.({\n                    code\n                });\n            }\n            if (activeConnection === conn) {\n                // connection might have been replaced already\n                tryReconnect();\n            }\n            for (const [key, req] of Object.entries(pendingRequests)){\n                if (req.ws !== conn) {\n                    continue;\n                }\n                if (state === 'closed') {\n                    // If the connection was closed, we just call `complete()` on the request\n                    delete pendingRequests[key];\n                    req.callbacks.complete?.();\n                    continue;\n                }\n                // The connection was closed either unexpectedly or because of a reconnect\n                if (req.type === 'subscription') {\n                    // Subscriptions will resume after we've reconnected\n                    resumeSubscriptionOnReconnect(req);\n                } else {\n                    // Queries and mutations will error if interrupted\n                    delete pendingRequests[key];\n                    req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError('WebSocket closed prematurely')));\n                }\n            }\n        });\n        return conn;\n    }\n    function request(op, callbacks) {\n        const { type , input , path , id  } = op;\n        const envelope = {\n            id,\n            method: type,\n            params: {\n                input,\n                path\n            }\n        };\n        pendingRequests[id] = {\n            ws: activeConnection,\n            type,\n            callbacks,\n            op\n        };\n        // enqueue message\n        outgoing.push(envelope);\n        dispatch();\n        return ()=>{\n            const callbacks = pendingRequests[id]?.callbacks;\n            delete pendingRequests[id];\n            outgoing = outgoing.filter((msg)=>msg.id !== id);\n            callbacks?.complete?.();\n            if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === 'subscription') {\n                outgoing.push({\n                    id,\n                    method: 'subscription.stop'\n                });\n                dispatch();\n            }\n        };\n    }\n    return {\n        close: ()=>{\n            state = 'closed';\n            onClose?.();\n            closeActiveSubscriptions();\n            closeIfNoPending(activeConnection);\n            clearTimeout(connectTimer);\n            connectTimer = null;\n        },\n        request,\n        getConnection () {\n            return activeConnection;\n        }\n    };\n}\nclass TRPCWebSocketClosedError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'TRPCWebSocketClosedError';\n        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n    }\n}\n/**\n * @see https://trpc.io/docs/client/links/wsLink\n */ function wsLink(opts) {\n    return (runtime)=>{\n        const { client  } = opts;\n        return ({ op  })=>{\n            return observable((observer)=>{\n                const { type , path , id , context  } = op;\n                const input = runtime.transformer.serialize(op.input);\n                const unsub = client.request({\n                    type,\n                    path,\n                    input,\n                    id,\n                    context\n                }, {\n                    error (err) {\n                        observer.error(err);\n                        unsub();\n                    },\n                    complete () {\n                        observer.complete();\n                    },\n                    next (message) {\n                        const transformed = transformResult(message, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error));\n                            return;\n                        }\n                        observer.next({\n                            result: transformed.result\n                        });\n                        if (op.type !== 'subscription') {\n                            // if it isn't a subscription we don't care about next response\n                            unsub();\n                            observer.complete();\n                        }\n                    }\n                });\n                return ()=>{\n                    unsub();\n                };\n            });\n        };\n    };\n}\n\nexport { createWSClient, wsLink };\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,yBAAyB;AACpD,SAASC,CAAC,IAAIC,eAAe,QAAQ,iCAAiC;AACtE,SAASC,CAAC,IAAIC,eAAe,QAAQ,iCAAiC;AACtE,OAAO,qBAAqB;;AAE5B;AAAwC,MAAMC,UAAU,GAAIC,YAAY,IAAGA,YAAY,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAIF,YAAY,EAAE,KAAK,CAAC;AAE7I,SAASG,cAAcA,CAACC,IAAI,EAAE;EAC1B,MAAM;IAAEC,GAAG;IAAGC,SAAS,EAAEC,aAAa,GAAGD,SAAS;IAAGE,YAAY,EAAEC,YAAY,GAAGV,UAAU;IAAGW,MAAM;IAAGC;EAAW,CAAC,GAAGP,IAAI;EAC3H;EAAwC,IAAI,CAACG,aAAa,EAAE;IACxD,MAAM,IAAIK,KAAK,CAAC,8IAA8I,CAAC;EACnK;EACA;AACJ;AACA;EAAM,IAAIC,QAAQ,GAAG,EAAE;EACnB,MAAMC,eAAe,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC3C,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,aAAa,GAAG,IAAI;EACxB,IAAIC,YAAY,GAAG,IAAI;EACvB,IAAIC,gBAAgB,GAAGC,QAAQ,CAAC,CAAC;EACjC,IAAIC,KAAK,GAAG,YAAY;EACxB;AACJ;AACA;EAAM,SAASC,QAAQA,CAAA,EAAG;IAClB,IAAID,KAAK,KAAK,MAAM,IAAIJ,aAAa,EAAE;MACnC;IACJ;IACAA,aAAa,GAAGM,UAAU,CAAC,MAAI;MAC3BN,aAAa,GAAG,IAAI;MACpB,IAAIL,QAAQ,CAACY,MAAM,KAAK,CAAC,EAAE;QACvB;QACAL,gBAAgB,CAACM,IAAI,CAACC,IAAI,CAACC,SAAS,CAACf,QAAQ,CAACgB,GAAG,CAAC,CAAC,CAAC,CAAC;MACzD,CAAC,MAAM;QACH;QACAT,gBAAgB,CAACM,IAAI,CAACC,IAAI,CAACC,SAAS,CAACf,QAAQ,CAAC,CAAC;MACnD;MACA;MACAA,QAAQ,GAAG,EAAE;IACjB,CAAC,CAAC;EACN;EACA,SAASiB,YAAYA,CAAA,EAAG;IACpB,IAAIX,YAAY,KAAK,IAAI,IAAIG,KAAK,KAAK,QAAQ,EAAE;MAC7C;IACJ;IACA,MAAMS,OAAO,GAAGtB,YAAY,CAACQ,cAAc,EAAE,CAAC;IAC9Ce,aAAa,CAACD,OAAO,CAAC;EAC1B;EACA,SAASE,SAASA,CAAA,EAAG;IACjBX,KAAK,GAAG,YAAY;IACpB,MAAMY,aAAa,GAAGd,gBAAgB;IACtCA,gBAAgB,GAAGC,QAAQ,CAAC,CAAC;IAC7Bc,gBAAgB,CAACD,aAAa,CAAC;EACnC;EACA,SAASF,aAAaA,CAACI,EAAE,EAAE;IACvB,IAAIjB,YAAY,EAAE;MACd;IACJ;IACAG,KAAK,GAAG,YAAY;IACpBH,YAAY,GAAGK,UAAU,CAACS,SAAS,EAAEG,EAAE,CAAC;EAC5C;EACA,SAASD,gBAAgBA,CAACE,IAAI,EAAE;IAC5B;IACA,MAAMC,kBAAkB,GAAGvB,MAAM,CAACwB,MAAM,CAACzB,eAAe,CAAC,CAAC0B,IAAI,CAAEC,CAAC,IAAGA,CAAC,CAACC,EAAE,KAAKL,IAAI,CAAC;IAClF,IAAI,CAACC,kBAAkB,EAAE;MACrBD,IAAI,CAACM,KAAK,CAAC,CAAC;IAChB;EACJ;EACA,SAASC,wBAAwBA,CAAA,EAAG;IAChC7B,MAAM,CAACwB,MAAM,CAACzB,eAAe,CAAC,CAAC+B,OAAO,CAAEC,GAAG,IAAG;MAC1C,IAAIA,GAAG,CAACC,IAAI,KAAK,cAAc,EAAE;QAC7BD,GAAG,CAACE,SAAS,CAACC,QAAQ,CAAC,CAAC;MAC5B;IACJ,CAAC,CAAC;EACN;EACA,SAASC,6BAA6BA,CAACJ,GAAG,EAAE;IACxC,IAAIjC,QAAQ,CAAC2B,IAAI,CAAEW,CAAC,IAAGA,CAAC,CAACC,EAAE,KAAKN,GAAG,CAACO,EAAE,CAACD,EAAE,CAAC,EAAE;MACxC;IACJ;IACAE,OAAO,CAACR,GAAG,CAACO,EAAE,EAAEP,GAAG,CAACE,SAAS,CAAC;EAClC;EACA,SAAS3B,QAAQA,CAAA,EAAG;IAChB,MAAMkC,SAAS,GAAG,OAAOlD,GAAG,KAAK,UAAU,GAAGA,GAAG,CAAC,CAAC,GAAGA,GAAG;IACzD,MAAMgC,IAAI,GAAG,IAAI9B,aAAa,CAACgD,SAAS,CAAC;IACzCC,YAAY,CAACrC,YAAY,CAAC;IAC1BA,YAAY,GAAG,IAAI;IACnBkB,IAAI,CAACoB,gBAAgB,CAAC,MAAM,EAAE,MAAI;MAC9B,uCAAwC,IAAIpB,IAAI,KAAKjB,gBAAgB,EAAE;QACnE;MACJ;MACAH,cAAc,GAAG,CAAC;MAClBK,KAAK,GAAG,MAAM;MACdZ,MAAM,GAAG,CAAC;MACVa,QAAQ,CAAC,CAAC;IACd,CAAC,CAAC;IACFc,IAAI,CAACoB,gBAAgB,CAAC,OAAO,EAAE,MAAI;MAC/B,IAAIpB,IAAI,KAAKjB,gBAAgB,EAAE;QAC3BU,YAAY,CAAC,CAAC;MAClB;IACJ,CAAC,CAAC;IACF,MAAM4B,qBAAqB,GAAIZ,GAAG,IAAG;MACjC,IAAIA,GAAG,CAACa,MAAM,KAAK,WAAW,IAAItB,IAAI,KAAKjB,gBAAgB,EAAE;QACzD,IAAIE,KAAK,KAAK,MAAM,EAAE;UAClBX,OAAO,GAAG,CAAC;QACf;QACAsB,SAAS,CAAC,CAAC;QACX;QACA,KAAK,MAAM2B,UAAU,IAAI7C,MAAM,CAACwB,MAAM,CAACzB,eAAe,CAAC,EAAC;UACpD,IAAI8C,UAAU,CAACb,IAAI,KAAK,cAAc,EAAE;YACpCG,6BAA6B,CAACU,UAAU,CAAC;UAC7C;QACJ;MACJ;IACJ,CAAC;IACD,MAAMC,sBAAsB,GAAIC,IAAI,IAAG;MACnC,MAAMhB,GAAG,GAAGgB,IAAI,CAACV,EAAE,KAAK,IAAI,IAAItC,eAAe,CAACgD,IAAI,CAACV,EAAE,CAAC;MACxD,IAAI,CAACN,GAAG,EAAE;QACN;QACA;MACJ;MACAA,GAAG,CAACE,SAAS,CAACe,IAAI,GAAGD,IAAI,CAAC;MAC1B,IAAIhB,GAAG,CAACJ,EAAE,KAAKtB,gBAAgB,IAAIiB,IAAI,KAAKjB,gBAAgB,EAAE;QAC1D,MAAM4C,KAAK,GAAGlB,GAAG,CAACJ,EAAE;QACpB;QACAI,GAAG,CAACJ,EAAE,GAAGtB,gBAAgB;QACzBe,gBAAgB,CAAC6B,KAAK,CAAC;MAC3B;MACA,IAAI,QAAQ,IAAIF,IAAI,IAAIA,IAAI,CAACG,MAAM,CAAClB,IAAI,KAAK,SAAS,IAAIV,IAAI,KAAKjB,gBAAgB,EAAE;QACjF0B,GAAG,CAACE,SAAS,CAACC,QAAQ,CAAC,CAAC;MAC5B;IACJ,CAAC;IACDZ,IAAI,CAACoB,gBAAgB,CAAC,SAAS,EAAE,CAAC;MAAEK;IAAM,CAAC,KAAG;MAC1C,MAAMI,GAAG,GAAGvC,IAAI,CAACwC,KAAK,CAACL,IAAI,CAAC;MAC5B,IAAI,QAAQ,IAAII,GAAG,EAAE;QACjBR,qBAAqB,CAACQ,GAAG,CAAC;MAC9B,CAAC,MAAM;QACHL,sBAAsB,CAACK,GAAG,CAAC;MAC/B;MACA,IAAI7B,IAAI,KAAKjB,gBAAgB,IAAIE,KAAK,KAAK,QAAQ,EAAE;QACjD;QACAa,gBAAgB,CAACE,IAAI,CAAC;MAC1B;IACJ,CAAC,CAAC;IACFA,IAAI,CAACoB,gBAAgB,CAAC,OAAO,EAAE,CAAC;MAAEW;IAAM,CAAC,KAAG;MACxC,IAAI9C,KAAK,KAAK,MAAM,EAAE;QAClBX,OAAO,GAAG;UACNyD;QACJ,CAAC,CAAC;MACN;MACA,IAAIhD,gBAAgB,KAAKiB,IAAI,EAAE;QAC3B;QACAP,YAAY,CAAC,CAAC;MAClB;MACA,KAAK,MAAM,CAACuC,GAAG,EAAEvB,GAAG,CAAC,IAAI/B,MAAM,CAACuD,OAAO,CAACxD,eAAe,CAAC,EAAC;QACrD,IAAIgC,GAAG,CAACJ,EAAE,KAAKL,IAAI,EAAE;UACjB;QACJ;QACA,IAAIf,KAAK,KAAK,QAAQ,EAAE;UACpB;UACA,OAAOR,eAAe,CAACuD,GAAG,CAAC;UAC3BvB,GAAG,CAACE,SAAS,CAACC,QAAQ,GAAG,CAAC;UAC1B;QACJ;QACA;QACA,IAAIH,GAAG,CAACC,IAAI,KAAK,cAAc,EAAE;UAC7B;UACAG,6BAA6B,CAACJ,GAAG,CAAC;QACtC,CAAC,MAAM;UACH;UACA,OAAOhC,eAAe,CAACuD,GAAG,CAAC;UAC3BvB,GAAG,CAACE,SAAS,CAACuB,KAAK,GAAGzE,eAAe,CAAC0E,IAAI,CAAC,IAAIC,wBAAwB,CAAC,8BAA8B,CAAC,CAAC,CAAC;QAC7G;MACJ;IACJ,CAAC,CAAC;IACF,OAAOpC,IAAI;EACf;EACA,SAASiB,OAAOA,CAACD,EAAE,EAAEL,SAAS,EAAE;IAC5B,MAAM;MAAED,IAAI;MAAG2B,KAAK;MAAGC,IAAI;MAAGvB;IAAI,CAAC,GAAGC,EAAE;IACxC,MAAMuB,QAAQ,GAAG;MACbxB,EAAE;MACFO,MAAM,EAAEZ,IAAI;MACZ8B,MAAM,EAAE;QACJH,KAAK;QACLC;MACJ;IACJ,CAAC;IACD7D,eAAe,CAACsC,EAAE,CAAC,GAAG;MAClBV,EAAE,EAAEtB,gBAAgB;MACpB2B,IAAI;MACJC,SAAS;MACTK;IACJ,CAAC;IACD;IACAxC,QAAQ,CAACiE,IAAI,CAACF,QAAQ,CAAC;IACvBrD,QAAQ,CAAC,CAAC;IACV,OAAO,MAAI;MACP,MAAMyB,SAAS,GAAGlC,eAAe,CAACsC,EAAE,CAAC,EAAEJ,SAAS;MAChD,OAAOlC,eAAe,CAACsC,EAAE,CAAC;MAC1BvC,QAAQ,GAAGA,QAAQ,CAACkE,MAAM,CAAEb,GAAG,IAAGA,GAAG,CAACd,EAAE,KAAKA,EAAE,CAAC;MAChDJ,SAAS,EAAEC,QAAQ,GAAG,CAAC;MACvB,IAAI7B,gBAAgB,CAAC4D,UAAU,KAAKzE,aAAa,CAAC0E,IAAI,IAAI5B,EAAE,CAACN,IAAI,KAAK,cAAc,EAAE;QAClFlC,QAAQ,CAACiE,IAAI,CAAC;UACV1B,EAAE;UACFO,MAAM,EAAE;QACZ,CAAC,CAAC;QACFpC,QAAQ,CAAC,CAAC;MACd;IACJ,CAAC;EACL;EACA,OAAO;IACHoB,KAAK,EAAEA,CAAA,KAAI;MACPrB,KAAK,GAAG,QAAQ;MAChBX,OAAO,GAAG,CAAC;MACXiC,wBAAwB,CAAC,CAAC;MAC1BT,gBAAgB,CAACf,gBAAgB,CAAC;MAClCoC,YAAY,CAACrC,YAAY,CAAC;MAC1BA,YAAY,GAAG,IAAI;IACvB,CAAC;IACDmC,OAAO;IACP4B,aAAaA,CAAA,EAAI;MACb,OAAO9D,gBAAgB;IAC3B;EACJ,CAAC;AACL;AACA,MAAMqD,wBAAwB,SAAS7D,KAAK,CAAC;EACzCuE,WAAWA,CAACC,OAAO,EAAC;IAChB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAG,0BAA0B;IACtCtE,MAAM,CAACuE,cAAc,CAAC,IAAI,EAAEb,wBAAwB,CAACc,SAAS,CAAC;EACnE;AACJ;AACA;AACA;AACA;AAAI,SAASC,MAAMA,CAACpF,IAAI,EAAE;EACtB,OAAQqF,OAAO,IAAG;IACd,MAAM;MAAEC;IAAQ,CAAC,GAAGtF,IAAI;IACxB,OAAO,CAAC;MAAEiD;IAAI,CAAC,KAAG;MACd,OAAO3D,UAAU,CAAEiG,QAAQ,IAAG;QAC1B,MAAM;UAAE5C,IAAI;UAAG4B,IAAI;UAAGvB,EAAE;UAAGwC;QAAS,CAAC,GAAGvC,EAAE;QAC1C,MAAMqB,KAAK,GAAGe,OAAO,CAACI,WAAW,CAACC,SAAS,CAACzC,EAAE,CAACqB,KAAK,CAAC;QACrD,MAAMqB,KAAK,GAAGL,MAAM,CAACpC,OAAO,CAAC;UACzBP,IAAI;UACJ4B,IAAI;UACJD,KAAK;UACLtB,EAAE;UACFwC;QACJ,CAAC,EAAE;UACCrB,KAAKA,CAAEyB,GAAG,EAAE;YACRL,QAAQ,CAACpB,KAAK,CAACyB,GAAG,CAAC;YACnBD,KAAK,CAAC,CAAC;UACX,CAAC;UACD9C,QAAQA,CAAA,EAAI;YACR0C,QAAQ,CAAC1C,QAAQ,CAAC,CAAC;UACvB,CAAC;UACDc,IAAIA,CAAEqB,OAAO,EAAE;YACX,MAAMa,WAAW,GAAGrG,eAAe,CAACwF,OAAO,EAAEK,OAAO,CAAC;YACrD,IAAI,CAACQ,WAAW,CAACC,EAAE,EAAE;cACjBP,QAAQ,CAACpB,KAAK,CAACzE,eAAe,CAAC0E,IAAI,CAACyB,WAAW,CAAC1B,KAAK,CAAC,CAAC;cACvD;YACJ;YACAoB,QAAQ,CAAC5B,IAAI,CAAC;cACVE,MAAM,EAAEgC,WAAW,CAAChC;YACxB,CAAC,CAAC;YACF,IAAIZ,EAAE,CAACN,IAAI,KAAK,cAAc,EAAE;cAC5B;cACAgD,KAAK,CAAC,CAAC;cACPJ,QAAQ,CAAC1C,QAAQ,CAAC,CAAC;YACvB;UACJ;QACJ,CAAC,CAAC;QACF,OAAO,MAAI;UACP8C,KAAK,CAAC,CAAC;QACX,CAAC;MACL,CAAC,CAAC;IACN,CAAC;EACL,CAAC;AACL;AAEA,SAAS5F,cAAc,EAAEqF,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}