{"ast":null,"code":"import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-b9d0cb48.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n                                                              * A function that should never be called unless we messed something up.\n                                                              */\nconst throwFatalError = () => {\n  throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */\nfunction dataLoader(batchLoader) {\n  let pendingItems = null;\n  let dispatchTimer = null;\n  const destroyTimerAndPendingItems = () => {\n    clearTimeout(dispatchTimer);\n    dispatchTimer = null;\n    pendingItems = null;\n  };\n  /**\n  * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n  */\n  function groupItems(items) {\n    const groupedItems = [[]];\n    let index = 0;\n    while (true) {\n      const item = items[index];\n      if (!item) {\n        break;\n      }\n      const lastGroup = groupedItems[groupedItems.length - 1];\n      if (item.aborted) {\n        // Item was aborted before it was dispatched\n        item.reject?.(new Error('Aborted'));\n        index++;\n        continue;\n      }\n      const isValid = batchLoader.validate(lastGroup.concat(item).map(it => it.key));\n      if (isValid) {\n        lastGroup.push(item);\n        index++;\n        continue;\n      }\n      if (lastGroup.length === 0) {\n        item.reject?.(new Error('Input is too big for a single dispatch'));\n        index++;\n        continue;\n      }\n      // Create new group, next iteration will try to add the item to that\n      groupedItems.push([]);\n    }\n    return groupedItems;\n  }\n  function dispatch() {\n    const groupedItems = groupItems(pendingItems);\n    destroyTimerAndPendingItems();\n    // Create batches for each group of items\n    for (const items of groupedItems) {\n      if (!items.length) {\n        continue;\n      }\n      const batch = {\n        items,\n        cancel: throwFatalError\n      };\n      for (const item of items) {\n        item.batch = batch;\n      }\n      const unitResolver = (index, value) => {\n        const item = batch.items[index];\n        item.resolve?.(value);\n        item.batch = null;\n        item.reject = null;\n        item.resolve = null;\n      };\n      const {\n        promise,\n        cancel\n      } = batchLoader.fetch(batch.items.map(_item => _item.key), unitResolver);\n      batch.cancel = cancel;\n      promise.then(result => {\n        for (let i = 0; i < result.length; i++) {\n          const value = result[i];\n          unitResolver(i, value);\n        }\n        for (const item of batch.items) {\n          item.reject?.(new Error('Missing result'));\n          item.batch = null;\n        }\n      }).catch(cause => {\n        for (const item of batch.items) {\n          item.reject?.(cause);\n          item.batch = null;\n        }\n      });\n    }\n  }\n  function load(key) {\n    const item = {\n      aborted: false,\n      key,\n      batch: null,\n      resolve: throwFatalError,\n      reject: throwFatalError\n    };\n    const promise = new Promise((resolve, reject) => {\n      item.reject = reject;\n      item.resolve = resolve;\n      if (!pendingItems) {\n        pendingItems = [];\n      }\n      pendingItems.push(item);\n    });\n    if (!dispatchTimer) {\n      dispatchTimer = setTimeout(dispatch);\n    }\n    const cancel = () => {\n      item.aborted = true;\n      if (item.batch?.items.every(item => item.aborted)) {\n        // All items in the batch have been cancelled\n        item.batch.cancel();\n        item.batch = null;\n      }\n    };\n    return {\n      promise,\n      cancel\n    };\n  }\n  return {\n    load\n  };\n}\n\n/**\n * @internal\n */\nfunction createHTTPBatchLink(requester) {\n  return function httpBatchLink(opts) {\n    const resolvedOpts = resolveHTTPLinkOptions(opts);\n    const maxURLLength = opts.maxURLLength ?? Infinity;\n    // initialized config\n    return runtime => {\n      const batchLoader = type => {\n        const validate = batchOps => {\n          if (maxURLLength === Infinity) {\n            // escape hatch for quick calcs\n            return true;\n          }\n          const path = batchOps.map(op => op.path).join(',');\n          const inputs = batchOps.map(op => op.input);\n          const url = getUrl({\n            ...resolvedOpts,\n            runtime,\n            type,\n            path,\n            inputs\n          });\n          return url.length <= maxURLLength;\n        };\n        const fetch = requester({\n          ...resolvedOpts,\n          runtime,\n          type,\n          opts\n        });\n        return {\n          validate,\n          fetch\n        };\n      };\n      const query = dataLoader(batchLoader('query'));\n      const mutation = dataLoader(batchLoader('mutation'));\n      const subscription = dataLoader(batchLoader('subscription'));\n      const loaders = {\n        query,\n        subscription,\n        mutation\n      };\n      return ({\n        op\n      }) => {\n        return observable(observer => {\n          const loader = loaders[op.type];\n          const {\n            promise,\n            cancel\n          } = loader.load(op);\n          let _res = undefined;\n          promise.then(res => {\n            _res = res;\n            const transformed = transformResult(res.json, runtime);\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error, {\n                meta: res.meta\n              }));\n              return;\n            }\n            observer.next({\n              context: res.meta,\n              result: transformed.result\n            });\n            observer.complete();\n          }).catch(err => {\n            observer.error(TRPCClientError.from(err, {\n              meta: _res?.meta\n            }));\n          });\n          return () => {\n            cancel();\n          };\n        });\n      };\n    };\n  };\n}\nconst batchRequester = requesterOpts => {\n  return batchOps => {\n    const path = batchOps.map(op => op.path).join(',');\n    const inputs = batchOps.map(op => op.input);\n    const {\n      promise,\n      cancel\n    } = jsonHttpRequester({\n      ...requesterOpts,\n      path,\n      inputs,\n      headers() {\n        if (!requesterOpts.opts.headers) {\n          return {};\n        }\n        if (typeof requesterOpts.opts.headers === 'function') {\n          return requesterOpts.opts.headers({\n            opList: batchOps\n          });\n        }\n        return requesterOpts.opts.headers;\n      }\n    });\n    return {\n      promise: promise.then(res => {\n        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);\n        const result = resJSON.map(item => ({\n          meta: res.meta,\n          json: item\n        }));\n        return result;\n      }),\n      cancel\n    };\n  };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\nexport { createHTTPBatchLink as c, httpBatchLink as h };","map":{"version":3,"names":["observable","t","transformResult","T","TRPCClientError","r","resolveHTTPLinkOptions","g","getUrl","j","jsonHttpRequester","throwFatalError","Error","dataLoader","batchLoader","pendingItems","dispatchTimer","destroyTimerAndPendingItems","clearTimeout","groupItems","items","groupedItems","index","item","lastGroup","length","aborted","reject","isValid","validate","concat","map","it","key","push","dispatch","batch","cancel","unitResolver","value","resolve","promise","fetch","_item","then","result","i","catch","cause","load","Promise","setTimeout","every","createHTTPBatchLink","requester","httpBatchLink","opts","resolvedOpts","maxURLLength","Infinity","runtime","type","batchOps","path","op","join","inputs","input","url","query","mutation","subscription","loaders","observer","loader","_res","undefined","res","transformed","json","ok","error","from","meta","next","context","complete","err","batchRequester","requesterOpts","headers","opList","resJSON","Array","isArray","c","h"],"sources":["/Users/danilakiva/jspool/s21_arcade_games/client/node_modules/@trpc/client/dist/httpBatchLink-d0f9eac9.mjs"],"sourcesContent":["import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-b9d0cb48.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items,\n                cancel: throwFatalError\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const unitResolver = (index, value)=>{\n                const item = batch.items[index];\n                item.resolve?.(value);\n                item.batch = null;\n                item.reject = null;\n                item.resolve = null;\n            };\n            const { promise , cancel  } = batchLoader.fetch(batch.items.map((_item)=>_item.key), unitResolver);\n            batch.cancel = cancel;\n            promise.then((result)=>{\n                for(let i = 0; i < result.length; i++){\n                    const value = result[i];\n                    unitResolver(i, value);\n                }\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        const cancel = ()=>{\n            item.aborted = true;\n            if (item.batch?.items.every((item)=>item.aborted)) {\n                // All items in the batch have been cancelled\n                item.batch.cancel();\n                item.batch = null;\n            }\n        };\n        return {\n            promise,\n            cancel\n        };\n    }\n    return {\n        load\n    };\n}\n\n/**\n * @internal\n */ function createHTTPBatchLink(requester) {\n    return function httpBatchLink(opts) {\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        const maxURLLength = opts.maxURLLength ?? Infinity;\n        // initialized config\n        return (runtime)=>{\n            const batchLoader = (type)=>{\n                const validate = (batchOps)=>{\n                    if (maxURLLength === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        inputs\n                    });\n                    return url.length <= maxURLLength;\n                };\n                const fetch = requester({\n                    ...resolvedOpts,\n                    runtime,\n                    type,\n                    opts\n                });\n                return {\n                    validate,\n                    fetch\n                };\n            };\n            const query = dataLoader(batchLoader('query'));\n            const mutation = dataLoader(batchLoader('mutation'));\n            const subscription = dataLoader(batchLoader('subscription'));\n            const loaders = {\n                query,\n                subscription,\n                mutation\n            };\n            return ({ op  })=>{\n                return observable((observer)=>{\n                    const loader = loaders[op.type];\n                    const { promise , cancel  } = loader.load(op);\n                    let _res = undefined;\n                    promise.then((res)=>{\n                        _res = res;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta: res.meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((err)=>{\n                        observer.error(TRPCClientError.from(err, {\n                            meta: _res?.meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n            };\n        };\n    };\n}\n\nconst batchRequester = (requesterOpts)=>{\n    return (batchOps)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { promise , cancel  } = jsonHttpRequester({\n            ...requesterOpts,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        });\n        return {\n            promise: promise.then((res)=>{\n                const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                const result = resJSON.map((item)=>({\n                        meta: res.meta,\n                        json: item\n                    }));\n                return result;\n            }),\n            cancel\n        };\n    };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\n\nexport { createHTTPBatchLink as c, httpBatchLink as h };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}