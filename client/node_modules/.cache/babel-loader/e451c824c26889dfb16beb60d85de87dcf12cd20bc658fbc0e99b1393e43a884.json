{"ast":null,"code":"import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-b9d0cb48.mjs';\nexport { b as getFetch } from './httpUtils-b9d0cb48.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-ace864b8.mjs';\nclass TRPCUntypedClient {\n  $request({\n    type,\n    input,\n    path,\n    context = {}\n  }) {\n    const chain$ = createChain({\n      links: this.links,\n      op: {\n        id: ++this.requestId,\n        type,\n        path,\n        input,\n        context\n      }\n    });\n    return chain$.pipe(share());\n  }\n  requestAsPromise(opts) {\n    const req$ = this.$request(opts);\n    const {\n      promise,\n      abort\n    } = observableToPromise(req$);\n    const abortablePromise = new Promise((resolve, reject) => {\n      opts.signal?.addEventListener('abort', abort);\n      promise.then(envelope => {\n        resolve(envelope.result.data);\n      }).catch(err => {\n        reject(TRPCClientError.from(err));\n      });\n    });\n    return abortablePromise;\n  }\n  query(path, input, opts) {\n    return this.requestAsPromise({\n      type: 'query',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal\n    });\n  }\n  mutation(path, input, opts) {\n    return this.requestAsPromise({\n      type: 'mutation',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal\n    });\n  }\n  subscription(path, input, opts) {\n    const observable$ = this.$request({\n      type: 'subscription',\n      path,\n      input,\n      context: opts?.context\n    });\n    return observable$.subscribe({\n      next(envelope) {\n        if (envelope.result.type === 'started') {\n          opts.onStarted?.();\n        } else if (envelope.result.type === 'stopped') {\n          opts.onStopped?.();\n        } else {\n          opts.onData?.(envelope.result.data);\n        }\n      },\n      error(err) {\n        opts.onError?.(err);\n      },\n      complete() {\n        opts.onComplete?.();\n      }\n    });\n  }\n  constructor(opts) {\n    this.requestId = 0;\n    const combinedTransformer = (() => {\n      const transformer = opts.transformer;\n      if (!transformer) {\n        return {\n          input: {\n            serialize: data => data,\n            deserialize: data => data\n          },\n          output: {\n            serialize: data => data,\n            deserialize: data => data\n          }\n        };\n      }\n      if ('input' in transformer) {\n        return opts.transformer;\n      }\n      return {\n        input: transformer,\n        output: transformer\n      };\n    })();\n    this.runtime = {\n      transformer: {\n        serialize: data => combinedTransformer.input.serialize(data),\n        deserialize: data => combinedTransformer.output.deserialize(data)\n      },\n      combinedTransformer\n    };\n    // Initialize the links\n    this.links = opts.links.map(link => link(this.runtime));\n  }\n}\nfunction createTRPCUntypedClient(opts) {\n  return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */\nfunction createTRPCClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return client;\n}\nconst clientCallTypeMap = {\n  query: 'query',\n  mutate: 'mutation',\n  subscribe: 'subscription'\n};\n/** @internal */\nconst clientCallTypeToProcedureType = clientCallType => {\n  return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */\nfunction createTRPCClientProxy(client) {\n  return createFlatProxy(key => {\n    if (client.hasOwnProperty(key)) {\n      return client[key];\n    }\n    if (key === '__untypedClient') {\n      return client;\n    }\n    return createRecursiveProxy(({\n      path,\n      args\n    }) => {\n      const pathCopy = [key, ...path];\n      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n      const fullPath = pathCopy.join('.');\n      return client[procedureType](fullPath, ...args);\n    });\n  });\n}\nfunction createTRPCProxyClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  const proxy = createTRPCClientProxy(client);\n  return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */\nfunction getUntypedClient(client) {\n  return client.__untypedClient;\n}\nfunction getTextDecoder(customTextDecoder) {\n  if (customTextDecoder) {\n    return customTextDecoder;\n  }\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (typeof window !== 'undefined' && window.TextDecoder) {\n    return new window.TextDecoder();\n  }\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n    return new globalThis.TextDecoder();\n  }\n  throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */\nasync function parseJSONStream(opts) {\n  const parse = opts.parse ?? JSON.parse;\n  const onLine = line => {\n    if (opts.signal?.aborted) return;\n    if (!line || line === '}') {\n      return;\n    }\n    /**\n    * At this point, `line` can be one of two things:\n    * - The first line of the stream `{\"2\":{...}`\n    * - A line in the middle of the stream `,\"2\":{...}`\n    */\n    const indexOfColon = line.indexOf(':');\n    const indexAsStr = line.substring(2, indexOfColon - 1);\n    const text = line.substring(indexOfColon + 1);\n    opts.onSingle(Number(indexAsStr), parse(text));\n  };\n  await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */\nasync function readLines(readableStream, onLine, textDecoder) {\n  let partOfLine = '';\n  const onChunk = chunk => {\n    const chunkText = textDecoder.decode(chunk);\n    const chunkLines = chunkText.split('\\n');\n    if (chunkLines.length === 1) {\n      partOfLine += chunkLines[0];\n    } else if (chunkLines.length > 1) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n      onLine(partOfLine + chunkLines[0]);\n      for (let i = 1; i < chunkLines.length - 1; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n        onLine(chunkLines[i]);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n      partOfLine = chunkLines[chunkLines.length - 1];\n    }\n  };\n  // we handle 2 different types of streams, this if where we figure out which one we have\n  if ('getReader' in readableStream) {\n    await readStandardChunks(readableStream, onChunk);\n  } else {\n    await readNodeChunks(readableStream, onChunk);\n  }\n  onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */\nfunction readNodeChunks(stream, onChunk) {\n  return new Promise(resolve => {\n    stream.on('data', onChunk);\n    stream.on('end', resolve);\n  });\n}\n/**\n * Handle WebAPI stream\n */\nasync function readStandardChunks(stream, onChunk) {\n  const reader = stream.getReader();\n  let readResult = await reader.read();\n  while (!readResult.done) {\n    onChunk(readResult.value);\n    readResult = await reader.read();\n  }\n}\nconst streamingJsonHttpRequester = (opts, onSingle) => {\n  const ac = opts.AbortController ? new opts.AbortController() : null;\n  const responsePromise = fetchHTTPResponse({\n    ...opts,\n    contentTypeHeader: 'application/json',\n    batchModeHeader: 'stream',\n    getUrl,\n    getBody: getBody$1\n  }, ac);\n  const cancel = () => ac?.abort();\n  const promise = responsePromise.then(async res => {\n    if (!res.body) throw new Error('Received response without body');\n    const meta = {\n      response: res\n    };\n    return parseJSONStream({\n      readableStream: res.body,\n      onSingle,\n      parse: string => ({\n        json: JSON.parse(string),\n        meta\n      }),\n      signal: ac?.signal,\n      textDecoder: opts.textDecoder\n    });\n  });\n  return {\n    cancel,\n    promise\n  };\n};\nconst streamRequester = requesterOpts => {\n  const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n  return (batchOps, unitResolver) => {\n    const path = batchOps.map(op => op.path).join(',');\n    const inputs = batchOps.map(op => op.input);\n    const {\n      cancel,\n      promise\n    } = streamingJsonHttpRequester({\n      ...requesterOpts,\n      textDecoder,\n      path,\n      inputs,\n      headers() {\n        if (!requesterOpts.opts.headers) {\n          return {};\n        }\n        if (typeof requesterOpts.opts.headers === 'function') {\n          return requesterOpts.opts.headers({\n            opList: batchOps\n          });\n        }\n        return requesterOpts.opts.headers;\n      }\n    }, (index, res) => {\n      unitResolver(index, res);\n    });\n    return {\n      /**\n      * return an empty array because the batchLoader expects an array of results\n      * but we've already called the `unitResolver` for each of them, there's\n      * nothing left to do here.\n      */\n      promise: promise.then(() => []),\n      cancel\n    };\n  };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\nconst getBody = opts => {\n  if (!('input' in opts)) {\n    return undefined;\n  }\n  if (!(opts.input instanceof FormData)) {\n    throw new Error('Input is not FormData');\n  }\n  return opts.input;\n};\nconst formDataRequester = opts => {\n  if (opts.type !== 'mutation') {\n    // TODO(?) handle formdata queries\n    throw new Error('We only handle mutations with formdata');\n  }\n  return httpRequest({\n    ...opts,\n    getUrl() {\n      return `${opts.url}/${opts.path}`;\n    },\n    getBody\n  });\n};\nconst experimental_formDataLink = httpLinkFactory({\n  requester: formDataRequester\n});\nexport { TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };","map":{"version":3,"names":["share","observableToPromise","c","createChain","s","splitLink","T","TRPCClientError","createFlatProxy","createRecursiveProxy","f","fetchHTTPResponse","g","getUrl","a","getBody$1","h","httpRequest","b","getFetch","createHTTPBatchLink","httpBatchLink","httpLinkFactory","httpLink","loggerLink","createWSClient","wsLink","TRPCUntypedClient","$request","type","input","path","context","chain$","links","op","id","requestId","pipe","requestAsPromise","opts","req$","promise","abort","abortablePromise","Promise","resolve","reject","signal","addEventListener","then","envelope","result","data","catch","err","from","query","mutation","subscription","observable$","subscribe","next","onStarted","onStopped","onData","error","onError","complete","onComplete","constructor","combinedTransformer","transformer","serialize","deserialize","output","runtime","map","link","createTRPCUntypedClient","createTRPCClient","client","clientCallTypeMap","mutate","clientCallTypeToProcedureType","clientCallType","createTRPCClientProxy","key","hasOwnProperty","args","pathCopy","procedureType","pop","fullPath","join","createTRPCProxyClient","proxy","getUntypedClient","__untypedClient","getTextDecoder","customTextDecoder","window","TextDecoder","globalThis","Error","parseJSONStream","parse","JSON","onLine","line","aborted","indexOfColon","indexOf","indexAsStr","substring","text","onSingle","Number","readLines","readableStream","textDecoder","partOfLine","onChunk","chunk","chunkText","decode","chunkLines","split","length","i","readStandardChunks","readNodeChunks","stream","on","reader","getReader","readResult","read","done","value","streamingJsonHttpRequester","ac","AbortController","responsePromise","contentTypeHeader","batchModeHeader","getBody","cancel","res","body","meta","response","string","json","streamRequester","requesterOpts","batchOps","unitResolver","inputs","headers","opList","index","unstable_httpBatchStreamLink","undefined","FormData","formDataRequester","url","experimental_formDataLink","requester"],"sources":["/Users/danilakiva/jspool/s21_arcade_games/node_modules/@trpc/client/dist/index.mjs"],"sourcesContent":["import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-b9d0cb48.mjs';\nexport { b as getFetch } from './httpUtils-b9d0cb48.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-ace864b8.mjs';\n\nclass TRPCUntypedClient {\n    $request({ type , input , path , context ={}  }) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                id: ++this.requestId,\n                type,\n                path,\n                input,\n                context\n            }\n        });\n        return chain$.pipe(share());\n    }\n    requestAsPromise(opts) {\n        const req$ = this.$request(opts);\n        const { promise , abort  } = observableToPromise(req$);\n        const abortablePromise = new Promise((resolve, reject)=>{\n            opts.signal?.addEventListener('abort', abort);\n            promise.then((envelope)=>{\n                resolve(envelope.result.data);\n            }).catch((err)=>{\n                reject(TRPCClientError.from(err));\n            });\n        });\n        return abortablePromise;\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts?.context\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                if (envelope.result.type === 'started') {\n                    opts.onStarted?.();\n                } else if (envelope.result.type === 'stopped') {\n                    opts.onStopped?.();\n                } else {\n                    opts.onData?.(envelope.result.data);\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        this.requestId = 0;\n        const combinedTransformer = (()=>{\n            const transformer = opts.transformer;\n            if (!transformer) {\n                return {\n                    input: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    },\n                    output: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    }\n                };\n            }\n            if ('input' in transformer) {\n                return opts.transformer;\n            }\n            return {\n                input: transformer,\n                output: transformer\n            };\n        })();\n        this.runtime = {\n            transformer: {\n                serialize: (data)=>combinedTransformer.input.serialize(data),\n                deserialize: (data)=>combinedTransformer.output.deserialize(data)\n            },\n            combinedTransformer\n        };\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */ function createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    return client;\n}\n\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */ function createTRPCClientProxy(client) {\n    return createFlatProxy((key)=>{\n        if (client.hasOwnProperty(key)) {\n            return client[key];\n        }\n        if (key === '__untypedClient') {\n            return client;\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n            const fullPath = pathCopy.join('.');\n            return client[procedureType](fullPath, ...args);\n        });\n    });\n}\nfunction createTRPCProxyClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client.__untypedClient;\n}\n\nfunction getTextDecoder(customTextDecoder) {\n    if (customTextDecoder) {\n        return customTextDecoder;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.TextDecoder) {\n        return new window.TextDecoder();\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n        return new globalThis.TextDecoder();\n    }\n    throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */ async function parseJSONStream(opts) {\n    const parse = opts.parse ?? JSON.parse;\n    const onLine = (line)=>{\n        if (opts.signal?.aborted) return;\n        if (!line || line === '}') {\n            return;\n        }\n        /**\n     * At this point, `line` can be one of two things:\n     * - The first line of the stream `{\"2\":{...}`\n     * - A line in the middle of the stream `,\"2\":{...}`\n     */ const indexOfColon = line.indexOf(':');\n        const indexAsStr = line.substring(2, indexOfColon - 1);\n        const text = line.substring(indexOfColon + 1);\n        opts.onSingle(Number(indexAsStr), parse(text));\n    };\n    await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */ async function readLines(readableStream, onLine, textDecoder) {\n    let partOfLine = '';\n    const onChunk = (chunk)=>{\n        const chunkText = textDecoder.decode(chunk);\n        const chunkLines = chunkText.split('\\n');\n        if (chunkLines.length === 1) {\n            partOfLine += chunkLines[0];\n        } else if (chunkLines.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n            onLine(partOfLine + chunkLines[0]);\n            for(let i = 1; i < chunkLines.length - 1; i++){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n                onLine(chunkLines[i]);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n            partOfLine = chunkLines[chunkLines.length - 1];\n        }\n    };\n    // we handle 2 different types of streams, this if where we figure out which one we have\n    if ('getReader' in readableStream) {\n        await readStandardChunks(readableStream, onChunk);\n    } else {\n        await readNodeChunks(readableStream, onChunk);\n    }\n    onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */ function readNodeChunks(stream, onChunk) {\n    return new Promise((resolve)=>{\n        stream.on('data', onChunk);\n        stream.on('end', resolve);\n    });\n}\n/**\n * Handle WebAPI stream\n */ async function readStandardChunks(stream, onChunk) {\n    const reader = stream.getReader();\n    let readResult = await reader.read();\n    while(!readResult.done){\n        onChunk(readResult.value);\n        readResult = await reader.read();\n    }\n}\nconst streamingJsonHttpRequester = (opts, onSingle)=>{\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const responsePromise = fetchHTTPResponse({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        batchModeHeader: 'stream',\n        getUrl,\n        getBody: getBody$1\n    }, ac);\n    const cancel = ()=>ac?.abort();\n    const promise = responsePromise.then(async (res)=>{\n        if (!res.body) throw new Error('Received response without body');\n        const meta = {\n            response: res\n        };\n        return parseJSONStream({\n            readableStream: res.body,\n            onSingle,\n            parse: (string)=>({\n                    json: JSON.parse(string),\n                    meta\n                }),\n            signal: ac?.signal,\n            textDecoder: opts.textDecoder\n        });\n    });\n    return {\n        cancel,\n        promise\n    };\n};\n\nconst streamRequester = (requesterOpts)=>{\n    const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n    return (batchOps, unitResolver)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { cancel , promise  } = streamingJsonHttpRequester({\n            ...requesterOpts,\n            textDecoder,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        }, (index, res)=>{\n            unitResolver(index, res);\n        });\n        return {\n            /**\n       * return an empty array because the batchLoader expects an array of results\n       * but we've already called the `unitResolver` for each of them, there's\n       * nothing left to do here.\n       */ promise: promise.then(()=>[]),\n            cancel\n        };\n    };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\n\nconst getBody = (opts)=>{\n    if (!('input' in opts)) {\n        return undefined;\n    }\n    if (!(opts.input instanceof FormData)) {\n        throw new Error('Input is not FormData');\n    }\n    return opts.input;\n};\nconst formDataRequester = (opts)=>{\n    if (opts.type !== 'mutation') {\n        // TODO(?) handle formdata queries\n        throw new Error('We only handle mutations with formdata');\n    }\n    return httpRequest({\n        ...opts,\n        getUrl () {\n            return `${opts.url}/${opts.path}`;\n        },\n        getBody\n    });\n};\nconst experimental_formDataLink = httpLinkFactory({\n    requester: formDataRequester\n});\n\nexport { TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}