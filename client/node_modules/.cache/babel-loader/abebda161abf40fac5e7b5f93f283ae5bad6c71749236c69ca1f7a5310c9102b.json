{"ast":null,"code":"import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';\nimport { g as getArrayQueryKey } from './getArrayQueryKey-86134f8b.mjs';\nimport { createTRPCClientProxy, createTRPCClient } from '@trpc/client';\nimport { useQuery, useQueryClient, useMutation, hashQueryKey, useInfiniteQuery, useQueries } from '@tanstack/react-query';\nimport React, { createContext, useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * We treat `undefined` as an input the same as omitting an `input`\n * https://github.com/trpc/trpc/issues/2290\n */\nfunction getQueryKeyInternal(path, input) {\n  if (path.length) return input === undefined ? [path] : [path, input];\n  return [];\n}\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @link https://trpc.io/docs/getQueryKey\n */\nfunction getQueryKey(..._params) {\n  const [procedureOrRouter, input, type] = _params;\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedureOrRouter._def().path;\n  const dotPath = path.join('.');\n  const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? 'any');\n  return queryKey;\n}\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */\nfunction createReactProxyDecoration(name, hooks) {\n  return createRecursiveProxy(opts => {\n    const args = opts.args;\n    const pathCopy = [name, ...opts.path];\n    // The last arg is for instance `.useMutation` or `.useQuery()`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastArg = pathCopy.pop();\n    // The `path` ends up being something like `post.byId`\n    const path = pathCopy.join('.');\n    if (lastArg === 'useMutation') {\n      return hooks[lastArg](path, ...args);\n    }\n    const [input, ...rest] = args;\n    const queryKey = getQueryKeyInternal(path, input);\n    // Expose queryKey helper\n    if (lastArg === 'getQueryKey') {\n      return getArrayQueryKey(queryKey, rest[0] ?? 'any');\n    }\n    if (lastArg === '_def') {\n      return {\n        path: pathCopy\n      };\n    }\n    if (lastArg.startsWith('useSuspense')) {\n      const opts1 = rest[0] || {};\n      const fn = lastArg === 'useSuspenseQuery' ? 'useQuery' : 'useInfiniteQuery';\n      const result = hooks[fn](queryKey, {\n        ...opts1,\n        suspense: true,\n        enabled: true\n      });\n      return [result.data, result];\n    }\n    return hooks[lastArg](queryKey, ...rest);\n  });\n}\nconst contextProps = ['client', 'ssrContext', 'ssrState', 'abortOnUnmount'];\nconst TRPCContext = /*#__PURE__*/createContext(null);\n\n/**\n * @internal\n */\nfunction createReactQueryUtilsProxy(context) {\n  return createFlatProxy(key => {\n    const contextName = key;\n    if (contextName === 'client') {\n      return createTRPCClientProxy(context.client);\n    }\n    if (contextProps.includes(contextName)) {\n      return context[contextName];\n    }\n    return createRecursiveProxy(({\n      path,\n      args\n    }) => {\n      const pathCopy = [key, ...path];\n      const utilName = pathCopy.pop();\n      const fullPath = pathCopy.join('.');\n      const getOpts = name => {\n        if (['setData', 'setInfiniteData'].includes(name)) {\n          const [input, updater, ...rest] = args;\n          const queryKey = getQueryKeyInternal(fullPath, input);\n          return {\n            queryKey,\n            updater,\n            rest\n          };\n        }\n        const [input1, ...rest1] = args;\n        const queryKey1 = getQueryKeyInternal(fullPath, input1);\n        return {\n          queryKey: queryKey1,\n          rest: rest1\n        };\n      };\n      const {\n        queryKey,\n        rest,\n        updater\n      } = getOpts(utilName);\n      const contextMap = {\n        fetch: () => context.fetchQuery(queryKey, ...rest),\n        fetchInfinite: () => context.fetchInfiniteQuery(queryKey, ...rest),\n        prefetch: () => context.prefetchQuery(queryKey, ...rest),\n        prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, ...rest),\n        ensureData: () => context.ensureQueryData(queryKey, ...rest),\n        invalidate: () => context.invalidateQueries(queryKey, ...rest),\n        reset: () => context.resetQueries(queryKey, ...rest),\n        refetch: () => context.refetchQueries(queryKey, ...rest),\n        cancel: () => context.cancelQuery(queryKey, ...rest),\n        setData: () => {\n          context.setQueryData(queryKey, updater, ...rest);\n        },\n        setInfiniteData: () => {\n          context.setInfiniteQueryData(queryKey, updater, ...rest);\n        },\n        getData: () => context.getQueryData(queryKey),\n        getInfiniteData: () => context.getInfiniteQueryData(queryKey)\n      };\n      return contextMap[utilName]();\n    });\n  });\n}\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */\nfunction createUseQueriesProxy(client) {\n  return createRecursiveProxy(opts => {\n    const path = opts.path.join('.');\n    const [input, _opts] = opts.args;\n    const queryKey = getQueryKeyInternal(path, input);\n    const options = {\n      queryKey,\n      queryFn: () => {\n        return client.query(path, input, _opts?.trpc);\n      },\n      ..._opts\n    };\n    return options;\n  });\n}\nfunction getClientArgs(pathAndInput, opts) {\n  const [path, input] = pathAndInput;\n  return [path, input, opts?.trpc];\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */\nfunction useHookResult(value) {\n  const ref = useRef(value);\n  ref.current.path = value.path;\n  return ref.current;\n}\n\n/**\n * @internal\n */\nfunction createRootHooks(config) {\n  const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? (options => options.originalFn());\n  const Context = config?.context ?? TRPCContext;\n  const ReactQueryContext = config?.reactQueryContext;\n  const createClient = opts => {\n    return createTRPCClient(opts);\n  };\n  const TRPCProvider = props => {\n    const {\n      abortOnUnmount = false,\n      client,\n      queryClient,\n      ssrContext\n    } = props;\n    const [ssrState, setSSRState] = useState(props.ssrState ?? false);\n    useEffect(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState(state => state ? 'mounted' : false);\n    }, []);\n    return /*#__PURE__*/React.createElement(Context.Provider, {\n      value: {\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext ?? null,\n        ssrState,\n        fetchQuery: useCallback((pathAndInput, opts) => {\n          return queryClient.fetchQuery({\n            ...opts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))\n          });\n        }, [client, queryClient]),\n        fetchInfiniteQuery: useCallback((pathAndInput, opts) => {\n          return queryClient.fetchInfiniteQuery({\n            ...opts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: ({\n              pageParam\n            }) => {\n              const [path, input] = pathAndInput;\n              const actualInput = {\n                ...input,\n                cursor: pageParam\n              };\n              return client.query(...getClientArgs([path, actualInput], opts));\n            }\n          });\n        }, [client, queryClient]),\n        prefetchQuery: useCallback((pathAndInput, opts) => {\n          return queryClient.prefetchQuery({\n            ...opts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))\n          });\n        }, [client, queryClient]),\n        prefetchInfiniteQuery: useCallback((pathAndInput, opts) => {\n          return queryClient.prefetchInfiniteQuery({\n            ...opts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: ({\n              pageParam\n            }) => {\n              const [path, input] = pathAndInput;\n              const actualInput = {\n                ...input,\n                cursor: pageParam\n              };\n              return client.query(...getClientArgs([path, actualInput], opts));\n            }\n          });\n        }, [client, queryClient]),\n        ensureQueryData: useCallback((pathAndInput, opts) => {\n          return queryClient.ensureQueryData({\n            ...opts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))\n          });\n        }, [client, queryClient]),\n        invalidateQueries: useCallback((queryKey, filters, options) => {\n          return queryClient.invalidateQueries({\n            ...filters,\n            queryKey: getArrayQueryKey(queryKey, 'any')\n          }, options);\n        }, [queryClient]),\n        resetQueries: useCallback((...args) => {\n          const [queryKey, filters, options] = args;\n          return queryClient.resetQueries({\n            ...filters,\n            queryKey: getArrayQueryKey(queryKey, 'any')\n          }, options);\n        }, [queryClient]),\n        refetchQueries: useCallback((...args) => {\n          const [queryKey, filters, options] = args;\n          return queryClient.refetchQueries({\n            ...filters,\n            queryKey: getArrayQueryKey(queryKey, 'any')\n          }, options);\n        }, [queryClient]),\n        cancelQuery: useCallback(pathAndInput => {\n          return queryClient.cancelQueries({\n            queryKey: getArrayQueryKey(pathAndInput, 'any')\n          });\n        }, [queryClient]),\n        setQueryData: useCallback((...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n        }, [queryClient]),\n        getQueryData: useCallback((...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n        }, [queryClient]),\n        setInfiniteQueryData: useCallback((...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n        }, [queryClient]),\n        getInfiniteQueryData: useCallback((...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n        }, [queryClient])\n      }\n    }, props.children);\n  };\n  function useContext() {\n    return React.useContext(Context);\n  }\n  /**\n  * Hack to make sure errors return `status`='error` when doing SSR\n  * @link https://github.com/trpc/trpc/pull/1645\n  */\n  function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {\n    const {\n      queryClient,\n      ssrState\n    } = useContext();\n    return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === 'error' ? {\n      retryOnMount: false,\n      ...opts\n    } : opts;\n  }\n  function useQuery$1(\n  // FIXME path should be a tuple in next major\n  pathAndInput, opts) {\n    const context = useContext();\n    if (!context) {\n      throw new Error('Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?');\n    }\n    const {\n      abortOnUnmount,\n      client,\n      ssrState,\n      queryClient,\n      prefetchQuery\n    } = context;\n    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'query'));\n    if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'query'))) {\n      void prefetchQuery(pathAndInput, opts);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'query', {\n      ...defaultOpts,\n      ...opts\n    });\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n    const hook = useQuery({\n      ...ssrOpts,\n      queryKey: getArrayQueryKey(pathAndInput, 'query'),\n      queryFn: queryFunctionContext => {\n        const actualOpts = {\n          ...ssrOpts,\n          trpc: {\n            ...ssrOpts?.trpc,\n            ...(shouldAbortOnUnmount ? {\n              signal: queryFunctionContext.signal\n            } : {})\n          }\n        };\n        return client.query(...getClientArgs(pathAndInput, actualOpts));\n      },\n      context: ReactQueryContext\n    });\n    hook.trpc = useHookResult({\n      path: pathAndInput[0]\n    });\n    return hook;\n  }\n  function useMutation$1(\n  // FIXME: this should only be a tuple path in next major\n  path, opts) {\n    const {\n      client\n    } = useContext();\n    const queryClient = useQueryClient({\n      context: ReactQueryContext\n    });\n    const actualPath = Array.isArray(path) ? path[0] : path;\n    const defaultOpts = queryClient.getMutationDefaults([actualPath.split('.')]);\n    const hook = useMutation({\n      ...opts,\n      mutationKey: [actualPath.split('.')],\n      mutationFn: input => {\n        return client.mutation(...getClientArgs([actualPath, input], opts));\n      },\n      context: ReactQueryContext,\n      onSuccess(...args) {\n        const originalFn = () => opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n        return mutationSuccessOverride({\n          originalFn,\n          queryClient,\n          meta: opts?.meta ?? defaultOpts?.meta ?? {}\n        });\n      }\n    });\n    hook.trpc = useHookResult({\n      path: actualPath\n    });\n    return hook;\n  }\n  /* istanbul ignore next -- @preserve */\n  function useSubscription(pathAndInput, opts) {\n    const enabled = opts?.enabled ?? true;\n    const queryKey = hashQueryKey(pathAndInput);\n    const {\n      client\n    } = useContext();\n    const optsRef = useRef(opts);\n    optsRef.current = opts;\n    useEffect(() => {\n      if (!enabled) {\n        return;\n      }\n      const [path, input] = pathAndInput;\n      let isStopped = false;\n      const subscription = client.subscription(path, input ?? undefined, {\n        onStarted: () => {\n          if (!isStopped) {\n            optsRef.current.onStarted?.();\n          }\n        },\n        onData: data => {\n          if (!isStopped) {\n            // FIXME this shouldn't be needed as both should be `unknown` in next major\n            optsRef.current.onData(data);\n          }\n        },\n        onError: err => {\n          if (!isStopped) {\n            optsRef.current.onError?.(err);\n          }\n        }\n      });\n      return () => {\n        isStopped = true;\n        subscription.unsubscribe();\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [queryKey, enabled]);\n  }\n  function useInfiniteQuery$1(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    const {\n      client,\n      ssrState,\n      prefetchInfiniteQuery,\n      queryClient,\n      abortOnUnmount\n    } = useContext();\n    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'infinite'));\n    if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'infinite'))) {\n      void prefetchInfiniteQuery(pathAndInput, {\n        ...defaultOpts,\n        ...opts\n      });\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'infinite', {\n      ...defaultOpts,\n      ...opts\n    });\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n    const hook = useInfiniteQuery({\n      ...ssrOpts,\n      queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n      queryFn: queryFunctionContext => {\n        const actualOpts = {\n          ...ssrOpts,\n          trpc: {\n            ...ssrOpts?.trpc,\n            ...(shouldAbortOnUnmount ? {\n              signal: queryFunctionContext.signal\n            } : {})\n          }\n        };\n        const actualInput = {\n          ...(input ?? {}),\n          cursor: queryFunctionContext.pageParam ?? opts?.initialCursor\n        };\n        // FIXME as any shouldn't be needed as client should be untyped too\n        return client.query(...getClientArgs([path, actualInput], actualOpts));\n      },\n      context: ReactQueryContext\n    });\n    hook.trpc = useHookResult({\n      path\n    });\n    return hook;\n  }\n  const useQueries$1 = (queriesCallback, context) => {\n    const {\n      ssrState,\n      queryClient,\n      prefetchQuery,\n      client\n    } = useContext();\n    const proxy = createUseQueriesProxy(client);\n    const queries = queriesCallback(proxy);\n    if (typeof window === 'undefined' && ssrState === 'prepass') {\n      for (const query of queries) {\n        const queryOption = query;\n        if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, 'query'))) {\n          void prefetchQuery(queryOption.queryKey, queryOption);\n        }\n      }\n    }\n    return useQueries({\n      queries: queries.map(query => ({\n        ...query,\n        queryKey: getArrayQueryKey(query.queryKey, 'query')\n      })),\n      context\n    });\n  };\n  const useDehydratedState = (client, trpcState) => {\n    const transformed = useMemo(() => {\n      if (!trpcState) {\n        return trpcState;\n      }\n      return client.runtime.transformer.deserialize(trpcState);\n    }, [trpcState, client]);\n    return transformed;\n  };\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useUtils: useContext,\n    useQuery: useQuery$1,\n    useQueries: useQueries$1,\n    useMutation: useMutation$1,\n    useSubscription,\n    useDehydratedState,\n    useInfiniteQuery: useInfiniteQuery$1\n  };\n}\n\n/**\n * Create strongly typed react hooks\n * @internal\n * @deprecated\n */\nfunction createHooksInternal(config) {\n  return createRootHooks(config);\n}\nexport { TRPCContext as T, createReactQueryUtilsProxy as a, createReactProxyDecoration as b, createHooksInternal as c, getClientArgs as d, createUseQueriesProxy as e, createRootHooks as f, getQueryKey as g, contextProps as h };","map":{"version":3,"names":["createRecursiveProxy","createFlatProxy","g","getArrayQueryKey","createTRPCClientProxy","createTRPCClient","useQuery","useQueryClient","useMutation","hashQueryKey","useInfiniteQuery","useQueries","React","createContext","useRef","useState","useEffect","useCallback","useMemo","getQueryKeyInternal","path","input","length","undefined","getQueryKey","_params","procedureOrRouter","type","_def","dotPath","join","queryKey","createReactProxyDecoration","name","hooks","opts","args","pathCopy","lastArg","pop","rest","startsWith","opts1","fn","result","suspense","enabled","data","contextProps","TRPCContext","createReactQueryUtilsProxy","context","key","contextName","client","includes","utilName","fullPath","getOpts","updater","input1","rest1","queryKey1","contextMap","fetch","fetchQuery","fetchInfinite","fetchInfiniteQuery","prefetch","prefetchQuery","prefetchInfinite","prefetchInfiniteQuery","ensureData","ensureQueryData","invalidate","invalidateQueries","reset","resetQueries","refetch","refetchQueries","cancel","cancelQuery","setData","setQueryData","setInfiniteData","setInfiniteQueryData","getData","getQueryData","getInfiniteData","getInfiniteQueryData","createUseQueriesProxy","_opts","options","queryFn","query","trpc","getClientArgs","pathAndInput","useHookResult","value","ref","current","createRootHooks","config","mutationSuccessOverride","overrides","unstable_overrides","onSuccess","originalFn","Context","ReactQueryContext","reactQueryContext","createClient","TRPCProvider","props","abortOnUnmount","queryClient","ssrContext","ssrState","setSSRState","state","createElement","Provider","pageParam","actualInput","cursor","filters","cancelQueries","children","useContext","useSSRQueryOptionsIfNeeded","getQueryCache","find","status","retryOnMount","useQuery$1","Error","defaultOpts","getQueryDefaults","window","ssr","ssrOpts","shouldAbortOnUnmount","hook","queryFunctionContext","actualOpts","signal","useMutation$1","actualPath","Array","isArray","getMutationDefaults","split","mutationKey","mutationFn","mutation","meta","useSubscription","optsRef","isStopped","subscription","onStarted","onData","onError","err","unsubscribe","useInfiniteQuery$1","initialCursor","useQueries$1","queriesCallback","proxy","queries","queryOption","map","useDehydratedState","trpcState","transformed","runtime","transformer","deserialize","useUtils","createHooksInternal","T","a","b","c","d","e","f","h"],"sources":["/Users/danilakiva/jspool/s21_arcade_games/client/node_modules/@trpc/react-query/dist/createHooksInternal-bdff7171.mjs"],"sourcesContent":["import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';\nimport { g as getArrayQueryKey } from './getArrayQueryKey-86134f8b.mjs';\nimport { createTRPCClientProxy, createTRPCClient } from '@trpc/client';\nimport { useQuery, useQueryClient, useMutation, hashQueryKey, useInfiniteQuery, useQueries } from '@tanstack/react-query';\nimport React, { createContext, useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * We treat `undefined` as an input the same as omitting an `input`\n * https://github.com/trpc/trpc/issues/2290\n */ function getQueryKeyInternal(path, input) {\n    if (path.length) return input === undefined ? [\n        path\n    ] : [\n        path,\n        input\n    ];\n    return [];\n}\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @link https://trpc.io/docs/getQueryKey\n */ function getQueryKey(..._params) {\n    const [procedureOrRouter, input, type] = _params;\n    // @ts-expect-error - we don't expose _def on the type layer\n    const path = procedureOrRouter._def().path;\n    const dotPath = path.join('.');\n    const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? 'any');\n    return queryKey;\n}\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */ function createReactProxyDecoration(name, hooks) {\n    return createRecursiveProxy((opts)=>{\n        const args = opts.args;\n        const pathCopy = [\n            name,\n            ...opts.path\n        ];\n        // The last arg is for instance `.useMutation` or `.useQuery()`\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastArg = pathCopy.pop();\n        // The `path` ends up being something like `post.byId`\n        const path = pathCopy.join('.');\n        if (lastArg === 'useMutation') {\n            return hooks[lastArg](path, ...args);\n        }\n        const [input, ...rest] = args;\n        const queryKey = getQueryKeyInternal(path, input);\n        // Expose queryKey helper\n        if (lastArg === 'getQueryKey') {\n            return getArrayQueryKey(queryKey, rest[0] ?? 'any');\n        }\n        if (lastArg === '_def') {\n            return {\n                path: pathCopy\n            };\n        }\n        if (lastArg.startsWith('useSuspense')) {\n            const opts1 = rest[0] || {};\n            const fn = lastArg === 'useSuspenseQuery' ? 'useQuery' : 'useInfiniteQuery';\n            const result = hooks[fn](queryKey, {\n                ...opts1,\n                suspense: true,\n                enabled: true\n            });\n            return [\n                result.data,\n                result\n            ];\n        }\n        return hooks[lastArg](queryKey, ...rest);\n    });\n}\n\nconst contextProps = [\n    'client',\n    'ssrContext',\n    'ssrState',\n    'abortOnUnmount'\n];\nconst TRPCContext = /*#__PURE__*/ createContext(null);\n\n/**\n * @internal\n */ function createReactQueryUtilsProxy(context) {\n    return createFlatProxy((key)=>{\n        const contextName = key;\n        if (contextName === 'client') {\n            return createTRPCClientProxy(context.client);\n        }\n        if (contextProps.includes(contextName)) {\n            return context[contextName];\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const utilName = pathCopy.pop();\n            const fullPath = pathCopy.join('.');\n            const getOpts = (name)=>{\n                if ([\n                    'setData',\n                    'setInfiniteData'\n                ].includes(name)) {\n                    const [input, updater, ...rest] = args;\n                    const queryKey = getQueryKeyInternal(fullPath, input);\n                    return {\n                        queryKey,\n                        updater,\n                        rest\n                    };\n                }\n                const [input1, ...rest1] = args;\n                const queryKey1 = getQueryKeyInternal(fullPath, input1);\n                return {\n                    queryKey: queryKey1,\n                    rest: rest1\n                };\n            };\n            const { queryKey , rest , updater  } = getOpts(utilName);\n            const contextMap = {\n                fetch: ()=>context.fetchQuery(queryKey, ...rest),\n                fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, ...rest),\n                prefetch: ()=>context.prefetchQuery(queryKey, ...rest),\n                prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, ...rest),\n                ensureData: ()=>context.ensureQueryData(queryKey, ...rest),\n                invalidate: ()=>context.invalidateQueries(queryKey, ...rest),\n                reset: ()=>context.resetQueries(queryKey, ...rest),\n                refetch: ()=>context.refetchQueries(queryKey, ...rest),\n                cancel: ()=>context.cancelQuery(queryKey, ...rest),\n                setData: ()=>{\n                    context.setQueryData(queryKey, updater, ...rest);\n                },\n                setInfiniteData: ()=>{\n                    context.setInfiniteQueryData(queryKey, updater, ...rest);\n                },\n                getData: ()=>context.getQueryData(queryKey),\n                getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)\n            };\n            return contextMap[utilName]();\n        });\n    });\n}\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */ function createUseQueriesProxy(client) {\n    return createRecursiveProxy((opts)=>{\n        const path = opts.path.join('.');\n        const [input, _opts] = opts.args;\n        const queryKey = getQueryKeyInternal(path, input);\n        const options = {\n            queryKey,\n            queryFn: ()=>{\n                return client.query(path, input, _opts?.trpc);\n            },\n            ..._opts\n        };\n        return options;\n    });\n}\n\nfunction getClientArgs(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    return [\n        path,\n        input,\n        opts?.trpc\n    ];\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */ function useHookResult(value) {\n    const ref = useRef(value);\n    ref.current.path = value.path;\n    return ref.current;\n}\n\n/**\n * @internal\n */ function createRootHooks(config) {\n    const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? ((options)=>options.originalFn());\n    const Context = config?.context ?? TRPCContext;\n    const ReactQueryContext = config?.reactQueryContext;\n    const createClient = (opts)=>{\n        return createTRPCClient(opts);\n    };\n    const TRPCProvider = (props)=>{\n        const { abortOnUnmount =false , client , queryClient , ssrContext  } = props;\n        const [ssrState, setSSRState] = useState(props.ssrState ?? false);\n        useEffect(()=>{\n            // Only updating state to `mounted` if we are using SSR.\n            // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n            setSSRState((state)=>state ? 'mounted' : false);\n        }, []);\n        return /*#__PURE__*/ React.createElement(Context.Provider, {\n            value: {\n                abortOnUnmount,\n                queryClient,\n                client,\n                ssrContext: ssrContext ?? null,\n                ssrState,\n                fetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                fetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                ensureQueryData: useCallback((pathAndInput, opts)=>{\n                    return queryClient.ensureQueryData({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                invalidateQueries: useCallback((queryKey, filters, options)=>{\n                    return queryClient.invalidateQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                resetQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.resetQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                refetchQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.refetchQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                cancelQuery: useCallback((pathAndInput)=>{\n                    return queryClient.cancelQueries({\n                        queryKey: getArrayQueryKey(pathAndInput, 'any')\n                    });\n                }, [\n                    queryClient\n                ]),\n                setQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                setInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ])\n            }\n        }, props.children);\n    };\n    function useContext() {\n        return React.useContext(Context);\n    }\n    /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */ function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {\n        const { queryClient , ssrState  } = useContext();\n        return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === 'error' ? {\n            retryOnMount: false,\n            ...opts\n        } : opts;\n    }\n    function useQuery$1(// FIXME path should be a tuple in next major\n    pathAndInput, opts) {\n        const context = useContext();\n        if (!context) {\n            throw new Error('Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?');\n        }\n        const { abortOnUnmount , client , ssrState , queryClient , prefetchQuery  } = context;\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'query'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'query'))) {\n            void prefetchQuery(pathAndInput, opts);\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'query', {\n            ...defaultOpts,\n            ...opts\n        });\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                return client.query(...getClientArgs(pathAndInput, actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path: pathAndInput[0]\n        });\n        return hook;\n    }\n    function useMutation$1(// FIXME: this should only be a tuple path in next major\n    path, opts) {\n        const { client  } = useContext();\n        const queryClient = useQueryClient({\n            context: ReactQueryContext\n        });\n        const actualPath = Array.isArray(path) ? path[0] : path;\n        const defaultOpts = queryClient.getMutationDefaults([\n            actualPath.split('.')\n        ]);\n        const hook = useMutation({\n            ...opts,\n            mutationKey: [\n                actualPath.split('.')\n            ],\n            mutationFn: (input)=>{\n                return client.mutation(...getClientArgs([\n                    actualPath,\n                    input\n                ], opts));\n            },\n            context: ReactQueryContext,\n            onSuccess (...args) {\n                const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n                return mutationSuccessOverride({\n                    originalFn,\n                    queryClient,\n                    meta: opts?.meta ?? defaultOpts?.meta ?? {}\n                });\n            }\n        });\n        hook.trpc = useHookResult({\n            path: actualPath\n        });\n        return hook;\n    }\n    /* istanbul ignore next -- @preserve */ function useSubscription(pathAndInput, opts) {\n        const enabled = opts?.enabled ?? true;\n        const queryKey = hashQueryKey(pathAndInput);\n        const { client  } = useContext();\n        const optsRef = useRef(opts);\n        optsRef.current = opts;\n        useEffect(()=>{\n            if (!enabled) {\n                return;\n            }\n            const [path, input] = pathAndInput;\n            let isStopped = false;\n            const subscription = client.subscription(path, input ?? undefined, {\n                onStarted: ()=>{\n                    if (!isStopped) {\n                        optsRef.current.onStarted?.();\n                    }\n                },\n                onData: (data)=>{\n                    if (!isStopped) {\n                        // FIXME this shouldn't be needed as both should be `unknown` in next major\n                        optsRef.current.onData(data);\n                    }\n                },\n                onError: (err)=>{\n                    if (!isStopped) {\n                        optsRef.current.onError?.(err);\n                    }\n                }\n            });\n            return ()=>{\n                isStopped = true;\n                subscription.unsubscribe();\n            };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            queryKey,\n            enabled\n        ]);\n    }\n    function useInfiniteQuery$1(pathAndInput, opts) {\n        const [path, input] = pathAndInput;\n        const { client , ssrState , prefetchInfiniteQuery , queryClient , abortOnUnmount ,  } = useContext();\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'infinite'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'infinite'))) {\n            void prefetchInfiniteQuery(pathAndInput, {\n                ...defaultOpts,\n                ...opts\n            });\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'infinite', {\n            ...defaultOpts,\n            ...opts\n        });\n        // request option should take priority over global\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useInfiniteQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                const actualInput = {\n                    ...input ?? {},\n                    cursor: queryFunctionContext.pageParam ?? opts?.initialCursor\n                };\n                // FIXME as any shouldn't be needed as client should be untyped too\n                return client.query(...getClientArgs([\n                    path,\n                    actualInput\n                ], actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path\n        });\n        return hook;\n    }\n    const useQueries$1 = (queriesCallback, context)=>{\n        const { ssrState , queryClient , prefetchQuery , client  } = useContext();\n        const proxy = createUseQueriesProxy(client);\n        const queries = queriesCallback(proxy);\n        if (typeof window === 'undefined' && ssrState === 'prepass') {\n            for (const query of queries){\n                const queryOption = query;\n                if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, 'query'))) {\n                    void prefetchQuery(queryOption.queryKey, queryOption);\n                }\n            }\n        }\n        return useQueries({\n            queries: queries.map((query)=>({\n                    ...query,\n                    queryKey: getArrayQueryKey(query.queryKey, 'query')\n                })),\n            context\n        });\n    };\n    const useDehydratedState = (client, trpcState)=>{\n        const transformed = useMemo(()=>{\n            if (!trpcState) {\n                return trpcState;\n            }\n            return client.runtime.transformer.deserialize(trpcState);\n        }, [\n            trpcState,\n            client\n        ]);\n        return transformed;\n    };\n    return {\n        Provider: TRPCProvider,\n        createClient,\n        useContext,\n        useUtils: useContext,\n        useQuery: useQuery$1,\n        useQueries: useQueries$1,\n        useMutation: useMutation$1,\n        useSubscription,\n        useDehydratedState,\n        useInfiniteQuery: useInfiniteQuery$1\n    };\n}\n\n/**\n * Create strongly typed react hooks\n * @internal\n * @deprecated\n */ function createHooksInternal(config) {\n    return createRootHooks(config);\n}\n\nexport { TRPCContext as T, createReactQueryUtilsProxy as a, createReactProxyDecoration as b, createHooksInternal as c, getClientArgs as d, createUseQueriesProxy as e, createRootHooks as f, getQueryKey as g, contextProps as h };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}